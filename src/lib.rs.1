use pyo3::prelude::*;
use pyo3::types::PyString;
use serde_json::Value;
use tauri::{image::Image, Emitter, Listener, Manager};
use std::{
    fs,
    path::PathBuf,
    str::FromStr,
    collections::HashMap,
    sync::Mutex,
};
use tauri::{AppHandle, Builder, WebviewWindowBuilder, Url};

mod python_utils;
use python_utils::pyany_to_json_value;

static APP_HANDLE: Mutex<Option<AppHandle>> = Mutex::new(None);
static FRONTEND_DIR: Mutex<Option<String>> = Mutex::new(None);

// Global storage for Python callbacks
static READY_CALLBACK: Mutex<Option<Py<PyAny>>> = Mutex::new(None);
static PYCOMMANDS_HANDLER: Mutex<Option<HashMap<String, PyObject>>> = Mutex::new(None);

#[pyclass]
struct TauriApp {
    _private: (), // To prevent direct instantiation
}

#[pymethods]
impl TauriApp {    

    #[staticmethod]
    fn on_ready(py: Python, callback: PyObject) -> PyResult<()> {
        // Store the Python callback
        let callback_ref = callback.clone_ref(py);
        READY_CALLBACK.lock().unwrap().replace(callback_ref);
        Ok(())
    }

    #[staticmethod]
    fn mount_frontend(path: String) -> PyResult<()> {
        *FRONTEND_DIR.lock().unwrap() = Some(path);
        Ok(())
    }

    #[staticmethod]
    fn create_window(
        label: String,
        title: String,
        url: String,
        user_agent: Option<String>,
        width: Option<i32>,
        height: Option<i32>,
        maximized: bool,
        center: bool,
    ) -> PyResult<()> {
        
        let app_handle = APP_HANDLE.lock().unwrap().clone().unwrap();
        
        let mut builder = WebviewWindowBuilder::new(
            &app_handle,
            label,
            tauri::WebviewUrl::External(Url::from_str(&url).unwrap()),
        )
        .title(title)
        .visible(true)
        .inner_size(width.unwrap_or(800) as f64, height.unwrap_or(600) as f64)
        .maximized(maximized)        
        .initialization_script(
            "window.invoke = async (command, args) => {
                args.command = command;
                let response = await window.__TAURI__.core.invoke('handle_py_command', {args: args});
                return response
            };
             window.listen = window.__TAURI__.event.listen;            
             window.emit = (message) => window.__TAURI__.event.emit('webview_emit', {message: message})",
        );

        if let Some(user_agent) = user_agent {
            builder = builder.user_agent(&user_agent);
        }

        if center {
            builder = builder.center();
        }
        
        builder.build().unwrap();
        
        Ok(())
    }

    #[staticmethod]
    fn close() -> PyResult<()> {
        if let Some(app_handle) = APP_HANDLE.lock().unwrap().clone() {
            app_handle.exit(0);
        }
        Ok(())
    }

    #[staticmethod]
    fn emit(event_type: String, event_data: String) -> PyResult<()> {
        if let Some(app_handle) = APP_HANDLE.lock().unwrap().clone() {
            app_handle.emit(&event_type, event_data).unwrap();
        }
        Ok(())
    }

    #[staticmethod]
    fn listen(_py: Python, callback: PyObject) -> PyResult<()> {
        let name = "listen".to_string();
        update_command_handler(name, callback);        
        Ok(())
    }

    #[staticmethod]
    fn register_commands(py: Python, handlers: Vec<PyObject>) -> PyResult<()> {       
            
        for handler in handlers {
            let name = handler.getattr(py, "__name__")?.extract::<String>(py)?;
            update_command_handler(name, handler);
        }

        Ok(())             
    }   

    #[staticmethod]
    fn run(
        py: Python,
        identifier: String,
        product_name: String,
        icon_path: Option<String>,
        on_ready: Option<PyObject>,
    ) -> PyResult<i32> {
        ctrlc::set_handler(move || {
            TauriApp::close().unwrap();
        }).unwrap();

        let mut context = tauri::generate_context!();
        let config = context.config_mut();
        
        config.identifier = identifier;
        config.product_name = Some(product_name.clone());
        config.app.with_global_tauri = true;
        
        let on_ready_py = on_ready.map(|cb| cb.clone_ref(py));
        
        let result = Builder::default()            
            .plugin(tauri_plugin_dialog::init())
            .register_uri_scheme_protocol("fs", |_app, request| {
                let front_dir = FRONTEND_DIR.lock().unwrap();
                let front_dir_opt = front_dir.as_ref().unwrap();
                let mut request_path = request.uri().path();
                if request_path == "/" {
                    request_path = "index.html";
                } else if request_path.starts_with('/') {
                    request_path = request_path.strip_prefix("/").unwrap();
                }
                let path = std::path::PathBuf::from(front_dir_opt).join(request_path);
      
                if path.exists() {
                    let content = fs::read(path).unwrap();
                    tauri::http::Response::builder()
                        .status(200)
                        .body(content)
                        .unwrap()
                } else {
                    tauri::http::Response::builder()
                        .status(404)
                        .body(Vec::new())
                        .unwrap()
                }
            })
            .setup(move |app| {
                *APP_HANDLE.lock().unwrap() = Some(app.handle().clone());

                if let Some(callback) = &on_ready_py {
                    Python::with_gil(|py| {
                        callback.call0(py).unwrap();
                    });
                }

                if let Some(handle) = APP_HANDLE.lock().unwrap().as_ref() {
                    let windows_hash =  handle.webview_windows();                   
                    let window = windows_hash.get("main").unwrap();
                    
                    if let Some(icon_path) = &icon_path {
                        let _ = window.set_icon(Image::from_path(PathBuf::from(icon_path)).unwrap());
                    } else {
                        eprintln!("Icon path is None, cannot set window icon.");
                    }
                    
                }

              
                
                //let app_handle = Arc::new(Mutex::new(app.handle()));
                app.listen("webview_emit", move |event| {
                    
                    println!("Received event in Rust: {:?}", event); // Debug event structure             
                    
                });

                //app.webview_windows()
                

                Ok(())
            })
            .invoke_handler(tauri::generate_handler![handle_py_command])
            .run(context);

        Ok(match result {
            Ok(_) => 0,
            Err(_) => 1,
        })
    }
}


#[tauri::command]
fn handle_py_command(args: Value) -> Result<Option<Value>, String> {   
    let command_name: String = args.get("command").unwrap().as_str().unwrap().to_string();
    let args_str = serde_json::to_string(&args).unwrap();
    let commands_handler = PYCOMMANDS_HANDLER.lock().unwrap();
    if let Some(commands) = commands_handler.as_ref() {        
        if let Some(callback) = commands.get(&command_name) {
            Ok(Some(Python::with_gil(|py| {
                let args_py = PyString::new(py, &args_str);
                let result = callback.call1(py, (args_py,)).unwrap();
                let result_value = pyany_to_json_value(&result).unwrap_or_default();
            
                Some(result_value)
               
            }).unwrap()))
        } else {
            Err("Please register command callback using register_commands()".into())
        }
    } else {
        Err("Please register command callbacks using register_commands()".into())
    }
    
}


fn update_command_handler(key: String, value: PyObject) {
    // Lock the mutex to get exclusive access
    let mut handler = PYCOMMANDS_HANDLER.lock().unwrap();
    
    // Check if the HashMap exists
    if handler.is_none() {
        // If it doesn't exist, create a new HashMap
        *handler = Some(HashMap::new());
    }
    
    // Now we know the HashMap exists, we can unwrap() safely and insert
    if let Some(map) = handler.as_mut() {
        map.insert(key, value);
    }
    //Mutex locks automatically
}


/// A Python module implemented in Rust.
#[pymodule]
fn python_tauri(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<TauriApp>()?;
    Ok(())
}
